// HARFANG(R) Copyright (C) 2022 NWNC. Released under GPL/LGPL/Commercial Licence, see licence.txt for details.

#define TEST_NO_MAIN
#include "acutest.h"

#include "foundation/data_rw_interface.h"

#include "engine/render_pipeline.h"

using namespace hg;

static Handle dummy_read_provider_open_impl(const std::string &path, bool silent) {
	static const uint8_t vsb[398] = {0x48, 0x47, 0x53, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x4A, 0x01, 0x00, 0x00, 0x04, 0x00, 0x6D, 0x61, 0x69, 0x6E, 0x02, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x61, 0x5F, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x61, 0x5F, 0x70, 0x6F, 0x73,
		0x69, 0x74, 0x69, 0x6F, 0x6E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x69, 0x5F, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x05, 0x00, 0x75, 0x5F, 0x6D, 0x74, 0x78, 0x40, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x6D, 0x6F,
		0x64, 0x65, 0x6C, 0x56, 0x69, 0x65, 0x77, 0x50, 0x72, 0x6F, 0x6A, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x01, 0x00, 0x00, 0x23,
		0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x33, 0x33, 0x30, 0x0A, 0x0A, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x4D, 0x61, 0x74, 0x72, 0x69,
		0x63, 0x65, 0x73, 0x0A, 0x7B, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x6D, 0x61, 0x74, 0x34, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x6C, 0x56, 0x69, 0x65, 0x77, 0x50,
		0x72, 0x6F, 0x6A, 0x3B, 0x0A, 0x7D, 0x3B, 0x0A, 0x0A, 0x75, 0x6E, 0x69, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x4D, 0x61, 0x74, 0x72, 0x69, 0x63, 0x65, 0x73,
		0x20, 0x75, 0x5F, 0x6D, 0x74, 0x78, 0x3B, 0x0A, 0x0A, 0x6F, 0x75, 0x74, 0x20, 0x76, 0x65, 0x63, 0x33, 0x20, 0x69, 0x5F, 0x6E, 0x6F, 0x72, 0x6D, 0x61,
		0x6C, 0x3B, 0x0A, 0x6C, 0x61, 0x79, 0x6F, 0x75, 0x74, 0x28, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x3D, 0x20, 0x31, 0x29, 0x20, 0x69,
		0x6E, 0x20, 0x76, 0x65, 0x63, 0x33, 0x20, 0x61, 0x5F, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x3B, 0x0A, 0x6C, 0x61, 0x79, 0x6F, 0x75, 0x74, 0x28, 0x6C,
		0x6F, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x3D, 0x20, 0x30, 0x29, 0x20, 0x69, 0x6E, 0x20, 0x76, 0x65, 0x63, 0x34, 0x20, 0x61, 0x5F, 0x70, 0x6F,
		0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3B, 0x0A, 0x0A, 0x76, 0x6F, 0x69, 0x64, 0x20, 0x6D, 0x61, 0x69, 0x6E, 0x28, 0x29, 0x0A, 0x7B, 0x0A, 0x20, 0x20,
		0x20, 0x20, 0x69, 0x5F, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x20, 0x3D, 0x20, 0x61, 0x5F, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x3B, 0x0A, 0x20, 0x20,
		0x20, 0x20, 0x67, 0x6C, 0x5F, 0x50, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x3D, 0x20, 0x75, 0x5F, 0x6D, 0x74, 0x78, 0x2E, 0x6D, 0x6F, 0x64,
		0x65, 0x6C, 0x56, 0x69, 0x65, 0x77, 0x50, 0x72, 0x6F, 0x6A, 0x20, 0x2A, 0x20, 0x61, 0x5F, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3B, 0x0A,
		0x7D, 0x0A, 0x0A};
	static const size_t vsb_size = 398;

	static const uint8_t fsb[197] = {0x48, 0x47, 0x53, 0x4C, 0x00, 0x00, 0x00, 0x01, 0x4A, 0x01, 0x00, 0x00, 0x04, 0x00, 0x6D, 0x61, 0x69, 0x6E, 0x01, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x69, 0x5F, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x6F, 0x5F, 0x63,
		0x6F, 0x6C, 0x6F, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x23, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x33, 0x33, 0x30,
		0x0A, 0x0A, 0x69, 0x6E, 0x20, 0x76, 0x65, 0x63, 0x33, 0x20, 0x69, 0x5F, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x3B, 0x0A, 0x6C, 0x61, 0x79, 0x6F, 0x75,
		0x74, 0x28, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x3D, 0x20, 0x30, 0x29, 0x20, 0x6F, 0x75, 0x74, 0x20, 0x76, 0x65, 0x63, 0x34, 0x20,
		0x6F, 0x5F, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3B, 0x0A, 0x0A, 0x76, 0x6F, 0x69, 0x64, 0x20, 0x6D, 0x61, 0x69, 0x6E, 0x28, 0x29, 0x0A, 0x7B, 0x0A, 0x20,
		0x20, 0x20, 0x20, 0x6F, 0x5F, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x20, 0x3D, 0x20, 0x76, 0x65, 0x63, 0x34, 0x28, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x69,
		0x7A, 0x65, 0x28, 0x69, 0x5F, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x29, 0x2E, 0x79, 0x79, 0x79, 0x2C, 0x20, 0x31, 0x2E, 0x30, 0x29, 0x3B, 0x0A, 0x7D,
		0x0A, 0x0A};
	static const size_t fsb_size = 197;

	Data *raw = new Data();
	if (path == "vertex") {
		raw->Write(vsb, vsb_size);
	} else {
		raw->Write(fsb, fsb_size);
	}
	raw->Rewind();

	DataReadHandle h(*raw);
	return h;
}

static void dummy_read_provide_close_impl(Handle hnd) {
	Data *data = *reinterpret_cast<Data **>(&hnd);
	data->Free();
	delete data;
}

static bool dummy_read_provider_is_file_impl(const std::string &path) {
	return true;
}

static void test_shader_load() {
	const ReadProvider dummy_read_provider = {dummy_read_provider_open_impl, dummy_read_provide_close_impl, dummy_read_provider_is_file_impl};
	Shader sh = LoadShader(g_data_reader, dummy_read_provider, "vertex", "fragment", false);
	TEST_CHECK(sh.shader.id != SG_INVALID_ID);
	sg_destroy_shader(sh.shader);
}

void test_render_pipeline() {
	sg_desc desc;
	memset(&desc, 0, sizeof(sg_desc));
	sg_setup(desc);

	test_shader_load();

	sg_shutdown();
}